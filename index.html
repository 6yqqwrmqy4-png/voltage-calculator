<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML Interface Project - Teams</title>
  <style>
    /* =============================
       Dark Theme (updated)
       ============================= */
    :root{
      --bg: #0b1220;
      --panel: #0f1a2b;
      --panel-2: #0c1626;
      --text: #e8eefc;
      --muted: #b7c3dd;
      --border: rgba(255,255,255,0.10);
      --shadow: 0 10px 25px rgba(0,0,0,0.45);

      --primary: #3b82f6;
      --primary-hover: #2563eb;

      --secondary: #334155;
      --secondary-hover: #1f2937;

      --table-head: #122544;
      --row-alt: rgba(255,255,255,0.03);

      --focus: rgba(59,130,246,0.35);
      --danger: #ef4444;
    }

    /* General Styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: var(--panel);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }

    h1, h2 {
      color: var(--text);
      text-align: center;
    }

    .form-wrapper {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-top: 20px;
    }

    .form-section {
      flex: 1;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--panel-2);
    }

    .form-section h2 {
      text-align: center;
      color: var(--primary);
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 10px;
      color: var(--muted);
    }

    input, select {
      padding: 10px;
      margin-top: 6px;
      margin-bottom: 15px;
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      background: rgba(255,255,255,0.04);
      color: var(--text);
      outline: none;
    }

    input::placeholder {
      color: rgba(232,238,252,0.45);
    }

    input:focus, select:focus {
      border-color: rgba(59,130,246,0.65);
      box-shadow: 0 0 0 4px var(--focus);
    }

    .flex-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: flex-start;
    }

    button {
      padding: 10px 15px;
      background-color: var(--primary);
      color: white;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.15s ease, transform 0.05s ease;
    }

    button:hover {
      background-color: var(--primary-hover);
    }

    button:active {
      transform: translateY(1px);
    }

    .btn-secondary {
      background: var(--secondary);
    }

    .btn-secondary:hover {
      background: var(--secondary-hover);
    }

    .btn-small {
      padding: 7px 10px;
      font-size: 13px;
      border-radius: 8px;
    }

    .table-container {
      margin-top: 20px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    th, td {
      border: 1px solid rgba(255,255,255,0.06);
      text-align: left;
      padding: 12px;
      vertical-align: top;
      color: var(--text);
    }

    th {
      background-color: var(--table-head);
      color: var(--text);
      white-space: nowrap;
    }

    tr:nth-child(even) {
      background-color: var(--row-alt);
    }

    .filters {
      margin-top: 20px;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    /* Hide/show filters */
    .filters-content {
      display: none;
      margin-top: 10px;
    }

    .filters-content.show {
      display: block;
    }

    /* Hide/show settings */
    .settings-content {
      display: none;
      margin-top: 10px;
    }

    .settings-content.show {
      display: block;
    }

    /* Calibration table styling */
    .settings-block {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      margin-top: 10px;
      background: var(--panel-2);
    }

    .settings-block h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: var(--text);
    }

    .cal-table-wrap {
      overflow-x: auto;
    }

    .cal-table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }

    .cal-table th, .cal-table td {
      border: 1px solid rgba(255,255,255,0.06);
      padding: 8px;
      vertical-align: middle;
      font-size: 13px;
    }

    .cal-table th {
      background: rgba(255,255,255,0.05);
      color: var(--text);
      white-space: nowrap;
    }

    .cal-table input {
      margin: 0;
      width: 100%;
      padding: 8px 10px;
      font-size: 13px;
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
    }

    .cal-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .tiny-note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    /* Modal overlay for target viewer */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 9999;
      backdrop-filter: blur(2px);
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: var(--panel);
      width: min(1000px, 100%);
      border-radius: 12px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    .modal-header h3 {
      margin: 0;
      font-size: 16px;
      color: var(--text);
    }

    .modal-body {
      padding: 12px;
    }

    .modal-body canvas {
      width: 100%;
      height: 520px;
      border: 1px solid var(--border);
      border-radius: 10px;
      display: block;
      background: rgba(255,255,255,0.02);
    }

    .distances-panel {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.03);
    }

    .distances-panel h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: var(--text);
    }

    .distances-panel table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(255,255,255,0.02);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .distances-panel th,
    .distances-panel td {
      border: 1px solid rgba(255,255,255,0.06);
      padding: 8px 10px;
      font-size: 13px;
    }

    .distances-panel th {
      background: rgba(255,255,255,0.05);
      color: var(--text);
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    /* Footer signature */
    .footer-signature {
      margin-top: 22px;
      padding-top: 14px;
      border-top: 1px solid var(--border);
      text-align: center;
      color: var(--muted);
      font-size: 12.5px;
      letter-spacing: 0.2px;
    }

    /* Make time input & select look consistent */
    input[type="time"] {
      color-scheme: dark;
    }
    select {
      color-scheme: dark;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Voltage Calculator</h1>

    <!-- Team Sections -->
    <div class="form-wrapper">
      <div class="form-section">
        <h2>Team #1</h2>
        <form id="team1-form">
          <label>
            MGRS Position (Grid Zone XXXX XXXX):
            <input type="text" id="team1-mgrs" placeholder="Enter MGRS Position" required />
          </label>
          <label>
            Line of Bearing (Degrees):
            <input type="number" id="team1-lob" placeholder="Enter LOB" required step="any" inputmode="decimal" />
          </label>
          <label>
            Frequency (MHz):
            <input type="text" id="team1-frequency" placeholder="Enter Frequency" required />
          </label>
          <label>
            Received Signal Strength Indicator (RSSI):
            <input type="text" id="team1-rssi" placeholder="Enter RSSI" required />
          </label>
          <button type="submit">Submit</button>
        </form>
      </div>

      <div class="form-section">
        <h2>Team #2</h2>
        <form id="team2-form">
          <label>
            MGRS Position (Grid Zone XXXX XXXX):
            <input type="text" id="team2-mgrs" placeholder="Enter MGRS Position" required />
          </label>
          <label>
            Line of Bearing (Degrees):
            <input type="number" id="team2-lob" placeholder="Enter LOB" required step="any" inputmode="decimal" />
          </label>
          <label>
            Frequency (MHz):
            <input type="text" id="team2-frequency" placeholder="Enter Frequency" required />
          </label>
          <label>
            Received Signal Strength Indicator (RSSI):
            <input type="text" id="team2-rssi" placeholder="Enter RSSI" required />
          </label>
          <button type="submit">Submit</button>
        </form>
      </div>
    </div>

    <!-- Targets Feature -->
    <div class="table-container">
      <h2>Targets</h2>
      <table id="targets-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>MGRS</th>
            <th>Frequency</th>
            <th>LOB Count</th>
            <th>View</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Filters + Settings -->
    <div class="filters">
      <div class="controls-row">
        <button type="button" id="toggle-filters-btn">Filter Data</button>
        <button type="button" id="toggle-settings-btn">Settings</button>
      </div>

      <div id="filters-content" class="filters-content">
        <div class="flex-row">
          <label>
            Start Time:
            <input type="time" id="filter-start-time" />
          </label>
          <label>
            End Time:
            <input type="time" id="filter-end-time" />
          </label>
        </div>

        <div class="flex-row">
          <label>
            LOB Start:
            <input type="number" id="filter-lob-start" placeholder="Start" step="any" inputmode="decimal" />
          </label>
          <label>
            LOB End:
            <input type="number" id="filter-lob-end" placeholder="End" step="any" inputmode="decimal" />
          </label>
          <label>
            MGRS Position:
            <input type="text" id="filter-mgrs" placeholder="Filter MGRS" />
          </label>
        </div>

        <div class="flex-row">
          <label>
            Frequency:
            <input type="text" id="filter-frequency" placeholder="Filter by Frequency" />
          </label>

          <label>
            Team:
            <select id="filter-team">
              <option value="">All Teams</option>
              <option value="Team #1">Team #1</option>
              <option value="Team #2">Team #2</option>
            </select>
          </label>
        </div>

        <div class="button-group">
          <button type="button" id="filter-btn">Apply Filters</button>
          <button type="button" id="reset-filters-btn">Reset Filters</button>
        </div>
      </div>

      <div id="settings-content" class="settings-content">

        <!-- ROT -->
        <div class="settings-block">
          <h3>ROT</h3>
          <div class="flex-row">
            <label style="flex:1;">
              ROT (0-9):
              <input type="number" id="settings-rot" placeholder="0" min="0" max="9" inputmode="numeric" />
            </label>
          </div>
          <div class="tiny-note">ROT adjusts only the numeric part of MGRS after the grid zone (e.g., 18SUJ stays unchanged).</div>
        </div>

        <!-- Calibration -->
        <div class="settings-block">
          <h3>Calibration</h3>

          <div class="cal-table-wrap">
            <table class="cal-table">
              <thead>
                <tr>
                  <th>Frequency Start</th>
                  <th>Frequency End</th>
                  <th>System</th>
                  <th>1km</th>
                  <th>3km</th>
                  <th>10km</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="calibration-tbody"></tbody>
            </table>
          </div>

          <div class="cal-actions">
            <button type="button" id="calibration-add-btn" class="btn-secondary btn-small">Add</button>
            <button type="button" id="calibration-clear-btn" class="btn-secondary btn-small">Clear Calibration</button>
          </div>

          <div class="tiny-note">Add creates a new row. Update saves that row into localStorage.</div>
        </div>

      </div>
    </div>

    <!-- Data Table -->
    <div class="table-container">
      <h2>Signal Database</h2>
      <table id="data-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Team</th>
            <th>MGRS Position</th>
            <th>Line of Bearing (LOB)</th>
            <th>Frequency</th>
            <th>RSSI</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Download and Clear Cache Buttons -->
    <div class="button-group">
      <button id="download-btn">Download as CSV</button>
      <button id="clear-cache-btn">Clear Cache</button>
    </div>

    <!-- Signature Footer -->
    <div class="footer-signature">Designed by William Parrish from 1/10 MTN DIV</div>
  </div>

  <!-- Modal for Target Viewer -->
  <div id="target-modal-overlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Target Viewer">
      <div class="modal-header">
        <h3 id="target-modal-title">Target Viewer</h3>
        <button type="button" id="close-target-modal" class="btn-secondary btn-small">Close</button>
      </div>
      <div class="modal-body">
        <canvas id="target-canvas" width="1000" height="520"></canvas>

        <div class="distances-panel" id="target-distance-panel">
          <h4>Distances to Intersection</h4>
          <div id="target-distance-list"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" id="redraw-target-modal" class="btn-secondary btn-small">Redraw</button>
        <button type="button" id="close-target-modal-2" class="btn-secondary btn-small">Close</button>
      </div>
    </div>
  </div>

  <!-- MGRS conversion library -->
  <script src="https://unpkg.com/mgrs/dist/mgrs.min.js"></script>

  <script>
    // -----------------------------
    // Storage Keys
    // -----------------------------
    const LOCAL_STORAGE_KEY = 'cachedData';
    const ROT_STORAGE_KEY = 'settingsROT';
    const CAL_STORAGE_KEY = 'calibrationRows';

    // -----------------------------
    // App Data
    // -----------------------------
    let cachedData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || [];

    // Load calibration rows and migrate older 5km/10km schema without breaking anything.
    // - Old rows used: km5, km10
    // - New rows use:  km1, km3, km10
    // This migration keeps old data from disappearing by mapping km5 -> km3 if km3 is empty.
    let calibrationRows = JSON.parse(localStorage.getItem(CAL_STORAGE_KEY)) || [];
    if (!Array.isArray(calibrationRows)) calibrationRows = [];
    calibrationRows = calibrationRows.map(r => {
      const row = (r && typeof r === 'object') ? { ...r } : {};
      // Ensure new keys exist
      if (row.km1 === undefined) row.km1 = '';
      if (row.km3 === undefined) row.km3 = '';
      if (row.km10 === undefined) row.km10 = '';
      // Migrate km5 into km3 if km3 is blank
      if ((row.km3 === '' || row.km3 == null) && (row.km5 != null && String(row.km5).trim() !== '')) {
        row.km3 = row.km5;
      }
      return row;
    });
    // Persist migrated shape once so future loads are consistent
    localStorage.setItem(CAL_STORAGE_KEY, JSON.stringify(calibrationRows));

    // -----------------------------
    // ROT helpers
    // -----------------------------
    function getRot() {
      const raw = localStorage.getItem(ROT_STORAGE_KEY);
      const n = raw === null ? 0 : parseInt(raw, 10);
      if (!Number.isFinite(n)) return 0;
      return Math.min(9, Math.max(0, n));
    }

    function setRot(val) {
      const n = parseInt(val, 10);
      const safe = Number.isFinite(n) ? Math.min(9, Math.max(0, n)) : 0;
      localStorage.setItem(ROT_STORAGE_KEY, String(safe));
      return safe;
    }

    // ROT applies only after the MGRS prefix (e.g., 18SUJ)
    function applyRotToMgrs(mgrsStr, rot) {
      const r = Number(rot);
      const shift = Number.isFinite(r) ? ((Math.trunc(r) % 10) + 10) % 10 : 0;
      const s = String(mgrsStr).trim();
      if (shift === 0) return s;

      const m = s.match(/^(\d{1,2}[C-HJ-NP-X][A-HJ-NP-Z]{2})(.*)$/i);
      if (m) {
        const prefix = m[1];
        const rest = m[2];
        const rotatedRest = rest.replace(/\d/g, d => String((Number(d) + shift) % 10));
        return prefix + rotatedRest;
      }

      const parts = s.split(/\s+/);
      if (parts.length <= 1) return s;
      const prefixToken = parts.shift();
      const restJoined = parts.join(' ');
      const rotatedRest = restJoined.replace(/\d/g, d => String((Number(d) + shift) % 10));
      return prefixToken + ' ' + rotatedRest;
    }

    // -----------------------------
    // DOM refs
    // -----------------------------
    const team1Form = document.getElementById('team1-form');
    const team2Form = document.getElementById('team2-form');

    const filterBtn = document.getElementById('filter-btn');
    const resetFiltersBtn = document.getElementById('reset-filters-btn');
    const downloadBtn = document.getElementById('download-btn');
    const clearCacheBtn = document.getElementById('clear-cache-btn');

    const dataTable = document.getElementById('data-table').querySelector('tbody');
    const targetsTableBody = document.getElementById('targets-table').querySelector('tbody');

    const toggleFiltersBtn = document.getElementById('toggle-filters-btn');
    const filtersContent = document.getElementById('filters-content');

    const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
    const settingsContent = document.getElementById('settings-content');

    const rotInput = document.getElementById('settings-rot');

    // Calibration DOM
    const calTbody = document.getElementById('calibration-tbody');
    const calAddBtn = document.getElementById('calibration-add-btn');
    const calClearBtn = document.getElementById('calibration-clear-btn');

    // -----------------------------
    // Toggle UI
    // -----------------------------
    toggleFiltersBtn.addEventListener('click', function () {
      filtersContent.classList.toggle('show');
    });

    toggleSettingsBtn.addEventListener('click', function () {
      settingsContent.classList.toggle('show');
    });

    // -----------------------------
    // ROT input behavior
    // -----------------------------
    rotInput.value = String(getRot());
    rotInput.addEventListener('input', function () {
      let v = rotInput.value.replace(/[^\d]/g, '');
      if (v === '') v = '0';
      v = String(Math.min(9, Math.max(0, parseInt(v, 10) || 0)));
      rotInput.value = v;
      setRot(v);
    });

    // -----------------------------
    // Calibration
    // -----------------------------
    function saveCalibration() {
      localStorage.setItem(CAL_STORAGE_KEY, JSON.stringify(calibrationRows));
    }

    function makeRowId() {
      return 'cal_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function renderCalibrationTable() {
      calTbody.innerHTML = '';
      if (!Array.isArray(calibrationRows)) calibrationRows = [];

      calibrationRows.forEach((row) => {
        const tr = document.createElement('tr');
        tr.dataset.rowId = row.id;

        tr.innerHTML = `
          <td><input type="text" value="${escapeHtml(row.freqStart ?? '')}" placeholder="e.g., 30.00" /></td>
          <td><input type="text" value="${escapeHtml(row.freqEnd ?? '')}" placeholder="e.g., 30.50" /></td>
          <td><input type="text" value="${escapeHtml(row.system ?? '')}" placeholder="e.g., System A" /></td>
          <td><input type="text" value="${escapeHtml(row.km1 ?? '')}" placeholder="" /></td>
          <td><input type="text" value="${escapeHtml(row.km3 ?? '')}" placeholder="" /></td>
          <td><input type="text" value="${escapeHtml(row.km10 ?? '')}" placeholder="" /></td>
          <td style="white-space:nowrap;">
            <button type="button" class="btn-secondary btn-small cal-update-btn">Update</button>
          </td>
        `;
        calTbody.appendChild(tr);
      });
    }

    calAddBtn.addEventListener('click', function () {
      calibrationRows.push({
        id: makeRowId(),
        freqStart: '',
        freqEnd: '',
        system: '',
        km1: '',
        km3: '',
        km10: ''
      });
      saveCalibration();
      renderCalibrationTable();
      // refresh targets in case calibration enables predictions for existing signals
      updateTargets();
    });

    calClearBtn.addEventListener('click', function () {
      if (confirm('Clear all calibration rows?')) {
        calibrationRows = [];
        saveCalibration();
        renderCalibrationTable();
        updateTargets();
      }
    });

    calTbody.addEventListener('click', function (e) {
      const btn = e.target.closest('.cal-update-btn');
      if (!btn) return;

      const tr = btn.closest('tr');
      if (!tr) return;

      const rowId = tr.dataset.rowId;
      const inputs = tr.querySelectorAll('input');
      if (inputs.length < 6) return;

      const updated = {
        id: rowId,
        freqStart: inputs[0].value.trim(),
        freqEnd: inputs[1].value.trim(),
        system: inputs[2].value.trim(),
        km1: inputs[3].value.trim(),
        km3: inputs[4].value.trim(),
        km10: inputs[5].value.trim()
      };

      const idx = calibrationRows.findIndex(r => r.id === rowId);
      if (idx === -1) return;

      calibrationRows[idx] = updated;
      saveCalibration();

      btn.textContent = 'Saved';
      setTimeout(() => { btn.textContent = 'Update'; }, 650);

      // refresh targets after changing calibration
      updateTargets();
    });

    // -----------------------------
    // Data Table Rendering
    // -----------------------------
    function renderTable(data) {
      dataTable.innerHTML = '';
      data.forEach(({ time, team, mgrs, lob, frequency, rssi }) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${time}</td>
          <td>${team}</td>
          <td>${mgrs}</td>
          <td>${lob}</td>
          <td>${frequency}</td>
          <td>${rssi ?? ''}</td>
        `;
        dataTable.appendChild(row);
      });
    }

    function submitData(team, mgrsId, lobId, frequencyId, rssiId) {
      const mgrsRaw = document.getElementById(mgrsId).value.trim();
      const lob = parseFloat(document.getElementById(lobId).value);
      const frequency = document.getElementById(frequencyId).value.trim();
      const rssi = document.getElementById(rssiId).value.trim();
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

      if (!mgrsRaw || isNaN(lob) || !frequency || !rssi) {
        alert('Please fill all fields.');
        return;
      }

      const rot = getRot();
      const mgrs = applyRotToMgrs(mgrsRaw, rot);

      const newEntry = { time, team, mgrs, lob, frequency, rssi };
      cachedData.push(newEntry);
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(cachedData));

      document.getElementById(mgrsId).value = mgrsRaw; // keep unrotated visible
      document.getElementById(lobId).value = '';
      document.getElementById(frequencyId).value = '';
      document.getElementById(rssiId).value = '';

      renderTable(cachedData);
      updateTargets(); // targets logic handles intersection first, then prediction fallback
    }

    team1Form.addEventListener('submit', function (e) {
      e.preventDefault();
      submitData('Team #1', 'team1-mgrs', 'team1-lob', 'team1-frequency', 'team1-rssi');
    });

    team2Form.addEventListener('submit', function (e) {
      e.preventDefault();
      submitData('Team #2', 'team2-mgrs', 'team2-lob', 'team2-frequency', 'team2-rssi');
    });

    // -----------------------------
    // Filters
    // -----------------------------
    function applyFilters() {
      const startTime = document.getElementById('filter-start-time').value;
      const endTime = document.getElementById('filter-end-time').value;
      const lobStart = parseFloat(document.getElementById('filter-lob-start').value);
      const lobEnd = parseFloat(document.getElementById('filter-lob-end').value);
      const mgrsFilter = document.getElementById('filter-mgrs').value.trim();
      const freqFilter = document.getElementById('filter-frequency').value.trim();
      const teamFilter = document.getElementById('filter-team').value;

      const startMinutes = startTime ? parseInt(startTime.split(':')[0]) * 60 + parseInt(startTime.split(':')[1]) : null;
      const endMinutes = endTime ? parseInt(endTime.split(':')[0]) * 60 + parseInt(endTime.split(':')[1]) : null;

      const filtered = cachedData.filter(({ time, lob, frequency, mgrs, team }) => {
        const [hours, minutes] = time.split(':').map(Number);
        const entryMinutes = hours * 60 + minutes;

        return (!startMinutes || entryMinutes >= startMinutes) &&
               (!endMinutes || entryMinutes <= endMinutes) &&
               (isNaN(lobStart) || lob >= lobStart) &&
               (isNaN(lobEnd) || lob <= lobEnd) &&
               (freqFilter ? String(frequency).includes(freqFilter) : true) &&
               (mgrsFilter ? String(mgrs).includes(mgrsFilter) : true) &&
               (teamFilter ? team === teamFilter : true);
      });

      renderTable(filtered);
    }

    filterBtn.addEventListener('click', applyFilters);

    resetFiltersBtn.addEventListener('click', function () {
      document.getElementById('filter-start-time').value = '';
      document.getElementById('filter-end-time').value = '';
      document.getElementById('filter-lob-start').value = '';
      document.getElementById('filter-lob-end').value = '';
      document.getElementById('filter-mgrs').value = '';
      document.getElementById('filter-frequency').value = '';
      document.getElementById('filter-team').value = '';
      renderTable(cachedData);
    });

    // -----------------------------
    // Cache controls
    // -----------------------------
    clearCacheBtn.addEventListener('click', function () {
      if (confirm('Are you sure you want to clear all cached data?')) {
        cachedData = [];
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        renderTable(cachedData);
        updateTargets();
      }
    });

    downloadBtn.addEventListener('click', function () {
      if (!cachedData.length) {
        alert('No data to download.');
        return;
      }

      const headers = ['Time', 'Team', 'MGRS Position', 'Line of Bearing (LOB)', 'Frequency', 'RSSI'];
      const csvContent = [headers.join(','), ...cachedData.map(entry =>
        `${entry.time},${entry.team},${entry.mgrs},${entry.lob},${entry.frequency},${entry.rssi}`
      )].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `cached_data.csv`;
      a.click();

      URL.revokeObjectURL(url);
    });

    // ============================================================
    // ENU FIX (replaces Mercator projection math)
    // ============================================================

    // -----------------------------
    // Targets Logic (unchanged constants)
    // -----------------------------
    const LOB_LENGTH_METERS = 50 * 1609.344; // 50 miles
    const FREQ_TOL = 0.25;
    const MIN_ANGLE_DEG = 5;
    const MERGE_INTERSECTION_METERS = 100;

    // New: MGRS precision for "6-digit" (100m) output
    const TARGET_MGRS_ACCURACY = 3; // 100m grid (6-digit)

    // New: clamp predicted RSSI distance to sane bounds (in km)
    const PREDICT_MIN_KM = 0.25;
    const PREDICT_MAX_KM = 60;

    function normalizeAngle(deg) {
      let a = deg % 360;
      if (a < 0) a += 360;
      return a;
    }

    function angleDiffDeg(a, b) {
      const d = Math.abs(normalizeAngle(a) - normalizeAngle(b)) % 360;
      return d > 180 ? 360 - d : d;
    }

    /**
     * Robust numeric parse that:
     * - normalizes unicode minus/dashes (− – — etc) to ASCII '-'
     * - strips commas (e.g., "3,100" -> "3100")
     * - extracts the first numeric token
     */
    function parseNumberLoose(val) {
      const s = String(val)
        .replace(/[\u2212\u2012\u2013\u2014]/g, '-') // normalize minus/dashes
        .replace(/,/g, '')                          // strip commas
        .trim();

      const m = s.match(/-?\d+(\.\d+)?/);
      return m ? parseFloat(m[0]) : NaN;
    }

    function parseFreq(val) {
      return parseNumberLoose(val);
    }

    function parseRssi(val) {
      return parseNumberLoose(val);
    }

    // -----------------------------
    // Calibration lookup + RSSI->distance
    // -----------------------------
    function findCalibrationForFreq(freqNum) {
      if (!Number.isFinite(freqNum)) return null;
      if (!Array.isArray(calibrationRows) || !calibrationRows.length) return null;

      for (const row of calibrationRows) {
        const fs = parseNumberLoose(row.freqStart);
        const fe = parseNumberLoose(row.freqEnd);
        if (!Number.isFinite(fs) || !Number.isFinite(fe)) continue;

        const lo = Math.min(fs, fe);
        const hi = Math.max(fs, fe);

        if (freqNum >= lo && freqNum <= hi) {
          const r1 = parseRssi(row.km1);
          const r3 = parseRssi(row.km3);
          const r10 = parseRssi(row.km10);

          // require all 3 points numeric
          if (!Number.isFinite(r1) || !Number.isFinite(r3) || !Number.isFinite(r10)) continue;

          return {
            id: row.id,
            freqStart: lo,
            freqEnd: hi,
            system: row.system ?? '',
            km1: r1,
            km3: r3,
            km10: r10
          };
        }
      }
      return null;
    }

    // Fit log-distance model: RSSI(d_km) = A - 10n log10(d_km)
    // Return {A,n} or null if ill-conditioned.
    function fitLogDistanceModel(cal) {
      if (!cal) return null;

      const xs = [Math.log10(1), Math.log10(3), Math.log10(10)];
      const ys = [cal.km1, cal.km3, cal.km10];

      const xbar = (xs[0] + xs[1] + xs[2]) / 3;
      const ybar = (ys[0] + ys[1] + ys[2]) / 3;

      let num = 0, den = 0;
      for (let i = 0; i < 3; i++) {
        const dx = xs[i] - xbar;
        const dy = ys[i] - ybar;
        num += dx * dy;
        den += dx * dx;
      }
      if (Math.abs(den) < 1e-12) return null;

      const m = num / den;        // y = b + m x
      const b = ybar - m * xbar;  // intercept

      const n = -m / 10;
      const A = b;

      if (!Number.isFinite(n) || !Number.isFinite(A) || n <= 0) return null;
      return { A, n };
    }

    function rssiToDistanceKm(rssiMeas, cal) {
      if (!Number.isFinite(rssiMeas) || !cal) return NaN;
      const model = fitLogDistanceModel(cal);
      if (!model) return NaN;

      const { A, n } = model;
      const d = Math.pow(10, (A - rssiMeas) / (10 * n));
      if (!Number.isFinite(d)) return NaN;

      // clamp to reduce nonsense
      return Math.min(PREDICT_MAX_KM, Math.max(PREDICT_MIN_KM, d));
    }

    // -----------------------------
    // Local ENU frame helpers (WGS84)
    // -----------------------------
    const WGS84_A = 6378137.0;
    const WGS84_F = 1 / 298.257223563;
    const WGS84_E2 = WGS84_F * (2 - WGS84_F);

    const d2r = d => d * Math.PI / 180;
    const r2d = r => r * 180 / Math.PI;

    function llhToEcef(lonDeg, latDeg, h = 0) {
      const lon = d2r(lonDeg), lat = d2r(latDeg);
      const s = Math.sin(lat), c = Math.cos(lat);
      const N = WGS84_A / Math.sqrt(1 - WGS84_E2 * s * s);

      const x = (N + h) * c * Math.cos(lon);
      const y = (N + h) * c * Math.sin(lon);
      const z = (N * (1 - WGS84_E2) + h) * s;
      return { x, y, z };
    }

    function ecefToLlh(x, y, z) {
      const b = WGS84_A * (1 - WGS84_F);
      const ep2 = (WGS84_A * WGS84_A - b * b) / (b * b);

      const p = Math.hypot(x, y);
      const th = Math.atan2(WGS84_A * z, b * p);
      const lon = Math.atan2(y, x);

      const sTh = Math.sin(th), cTh = Math.cos(th);
      const lat = Math.atan2(
        z + ep2 * b * sTh * sTh * sTh,
        p - WGS84_E2 * WGS84_A * cTh * cTh * cTh
      );

      return { lon: r2d(lon), lat: r2d(lat) };
    }

    function makeEnuFrame(lon0Deg, lat0Deg) {
      const lon0 = d2r(lon0Deg), lat0 = d2r(lat0Deg);
      const o = llhToEcef(lon0Deg, lat0Deg, 0);

      const sL = Math.sin(lon0), cL = Math.cos(lon0);
      const sB = Math.sin(lat0), cB = Math.cos(lat0);

      function ecefToEnu(x, y, z) {
        const dx = x - o.x, dy = y - o.y, dz = z - o.z;
        const e = -sL * dx + cL * dy;
        const n = -sB * cL * dx - sB * sL * dy + cB * dz;
        const u =  cB * cL * dx + cB * sL * dy + sB * dz;
        return { x: e, y: n, z: u };
      }

      function enuToEcef(e, n, u = 0) {
        return {
          x: o.x + (-sL) * e + (-sB * cL) * n + (cB * cL) * u,
          y: o.y + ( cL) * e + (-sB * sL) * n + (cB * sL) * u,
          z: o.z + (   0) * e + (   cB) * n + (   sB) * u
        };
      }

      return { ecefToEnu, enuToEcef, lon0Deg, lat0Deg };
    }

    // This is the ENU "world" coordinate system we use for ALL target math
    let enuFrame = null;

    function ensureEnuFrameFromEntries(entries) {
      // Anchor ENU near the average of points so coordinates stay well-conditioned.
      let lonSum = 0, latSum = 0, k = 0;

      for (const e of entries) {
        try {
          const ll = window.mgrs.toPoint(String(e.mgrs).trim()); // [lon, lat]
          lonSum += ll[0];
          latSum += ll[1];
          k++;
        } catch {}
      }

      if (!k) return null;
      enuFrame = makeEnuFrame(lonSum / k, latSum / k);
      return enuFrame;
    }

    function lonLatToXY(lon, lat) {
      if (!enuFrame) enuFrame = makeEnuFrame(lon, lat);
      const ecef = llhToEcef(lon, lat, 0);
      const enu = enuFrame.ecefToEnu(ecef.x, ecef.y, ecef.z);
      return { x: enu.x, y: enu.y };
    }

    function xyToLonLat(x, y) {
      if (!enuFrame) throw new Error('ENU frame not initialized');
      const ecef = enuFrame.enuToEcef(x, y, 0);
      const ll = ecefToLlh(ecef.x, ecef.y, ecef.z);
      return { lon: ll.lon, lat: ll.lat };
    }

    function mgrsToXY(mgrsStr) {
      const ll = window.mgrs.toPoint(String(mgrsStr).trim()); // [lon, lat]
      return lonLatToXY(ll[0], ll[1]);
    }

    // Default (unchanged) for internal intersections. Kept for backward compatibility.
    function xyToMgrs(x, y) {
      const ll = xyToLonLat(x, y);
      return window.mgrs.forward([ll.lon, ll.lat], 5); // 1m
    }

    // New: output 100m / 6-digit style MGRS for targets table
    function xyToMgrsTarget100m(x, y) {
      const ll = xyToLonLat(x, y);
      return window.mgrs.forward([ll.lon, ll.lat], TARGET_MGRS_ACCURACY);
    }

    // -----------------------------
    // Segment + intersection (unchanged math, now in ENU meters)
    // -----------------------------
    function segmentFromEntry(entry) {
      const p = mgrsToXY(entry.mgrs);

      // If your sensor LOB is true bearing (clockwise from true north),
      // ENU expects: 0° north, 90° east.
      const az = normalizeAngle(parseFloat(entry.lob));
      const rad = az * Math.PI / 180;

      // ENU: x=east, y=north
      const dx = Math.sin(rad);
      const dy = Math.cos(rad);

      const x2 = p.x + dx * LOB_LENGTH_METERS;
      const y2 = p.y + dy * LOB_LENGTH_METERS;

      return { x1: p.x, y1: p.y, x2, y2 };
    }

    function segmentIntersection(segA, segB) {
      const x1 = segA.x1, y1 = segA.y1, x2 = segA.x2, y2 = segA.y2;
      const x3 = segB.x1, y3 = segB.y1, x4 = segB.x2, y4 = segB.y2;

      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 1e-9) return null;

      const px = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / denom;
      const py = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / denom;

      function within(a, b, p) {
        return p >= Math.min(a, b) - 1e-6 && p <= Math.max(a, b) + 1e-6;
      }

      if (!within(x1, x2, px) || !within(y1, y2, py) || !within(x3, x4, px) || !within(y3, y4, py)) {
        return null;
      }

      return { x: px, y: py };
    }

    function distMeters(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function timeToSortableMinutes(t) {
      const parts = String(t).split(':');
      const h = parseInt(parts[0], 10);
      const m = parseInt(parts[1], 10);
      if (isNaN(h) || isNaN(m)) return Number.MAX_SAFE_INTEGER;
      return h * 60 + m;
    }

    function haversineKm(lon1, lat1, lon2, lat2) {
      const toRad = d => d * Math.PI / 180;
      const Rm = 6371008.8;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return (Rm * c) / 1000;
    }

    let lastTargets = [];

    // -----------------------------
    // Predicted target point from single entry (LOB + RSSI + calibration)
    // -----------------------------
    function predictedPointFromEntry(entry) {
      const freqNum = entry._freqNum;
      const rssiNum = entry._rssiNum;
      const lobNum = entry._lobNum;

      if (!Number.isFinite(freqNum) || !Number.isFinite(rssiNum) || !Number.isFinite(lobNum)) return null;

      const cal = findCalibrationForFreq(freqNum);
      if (!cal) return null;

      const dKm = rssiToDistanceKm(rssiNum, cal);
      if (!Number.isFinite(dKm)) return null;

      // observer point
      let p;
      try { p = mgrsToXY(entry.mgrs); }
      catch { return null; }

      const az = normalizeAngle(lobNum);
      const rad = az * Math.PI / 180;

      const dx = Math.sin(rad);
      const dy = Math.cos(rad);

      const distM = dKm * 1000;

      const x = p.x + dx * distM;
      const y = p.y + dy * distM;

      return { point: { x, y }, dKm, cal };
    }

    function updateTargets() {
      if (!window.mgrs || typeof window.mgrs.toPoint !== 'function') {
        targetsTableBody.innerHTML = '';
        lastTargets = [];
        return;
      }

      const entries = [];
      for (let i = 0; i < cachedData.length; i++) {
        const e = cachedData[i];
        const f = parseFreq(e.frequency);
        const lob = parseFloat(e.lob);
        const rssiNum = parseRssi(e.rssi);

        if (!Number.isFinite(f) || !Number.isFinite(lob)) continue;

        try {
          // validates mgrs
          window.mgrs.toPoint(String(e.mgrs).trim());
        } catch (err) { continue; }

        entries.push({ ...e, _idx: i, _freqNum: f, _lobNum: lob, _rssiNum: rssiNum });
      }

      // Build/refresh ENU frame based on current valid entries
      ensureEnuFrameFromEntries(entries);

      // -----------------------------
      // 1) INTERSECTION TARGETS (existing behavior)
      // -----------------------------
      const targets = [];
      for (let i = 0; i < entries.length; i++) {
        for (let j = i + 1; j < entries.length; j++) {
          const a = entries[i];
          const b = entries[j];

          if (Math.abs(a._freqNum - b._freqNum) > FREQ_TOL) continue;
          if (angleDiffDeg(a._lobNum, b._lobNum) <= MIN_ANGLE_DEG) continue;

          let inter = null;
          try {
            const segA = segmentFromEntry(a);
            const segB = segmentFromEntry(b);
            inter = segmentIntersection(segA, segB);
          } catch (err) {
            inter = null;
          }
          if (!inter) continue;

          const freqMid = (a._freqNum + b._freqNum) / 2;

          let merged = null;
          for (const t of targets) {
            if (Math.abs(t.freq - freqMid) <= FREQ_TOL && distMeters(t.point, inter) <= MERGE_INTERSECTION_METERS) {
              merged = t;
              break;
            }
          }

          if (!merged) {
            merged = { point: inter, freq: freqMid, entryIdxSet: new Set(), times: new Set(), type: 'intersection' };
            targets.push(merged);
          }

          merged.entryIdxSet.add(a._idx);
          merged.entryIdxSet.add(b._idx);
          merged.times.add(a.time);
          merged.times.add(b.time);
        }
      }

      const intersectionTargets = targets
        .filter(t => t.entryIdxSet.size >= 2)
        .map(t => {
          let mgrsOut = '';
          try { mgrsOut = xyToMgrsTarget100m(t.point.x, t.point.y); } catch (err) { mgrsOut = 'MGRS ERROR'; }
          const timesSorted = Array.from(t.times).sort((a, b) => timeToSortableMinutes(a) - timeToSortableMinutes(b));
          return {
            type: 'intersection',
            point: t.point,
            freq: t.freq,
            mgrs: mgrsOut,
            lobCount: t.entryIdxSet.size,
            entryIdxs: Array.from(t.entryIdxSet),
            timesSorted
          };
        });

      // Build a set of entries that are part of any intersection target
      const usedInIntersection = new Set();
      for (const t of intersectionTargets) {
        for (const idx of t.entryIdxs) usedInIntersection.add(idx);
      }

      // -----------------------------
      // 2) PREDICTED TARGETS (new behavior)
      // Only for entries NOT used in any intersection, and ONLY if calibration matches.
      // -----------------------------
      const predictedTargets = [];
      for (const e of entries) {
        if (usedInIntersection.has(e._idx)) continue;

        const pred = predictedPointFromEntry(e);
        if (!pred) continue;

        let mgrsOut = '';
        try { mgrsOut = xyToMgrsTarget100m(pred.point.x, pred.point.y); } catch { mgrsOut = 'MGRS ERROR'; }

        predictedTargets.push({
          type: 'predicted',
          point: pred.point,
          freq: e._freqNum,
          mgrs: mgrsOut,
          lobCount: 1,
          entryIdxs: [e._idx],
          timesSorted: [e.time],
          // extra metadata for viewer
          predictedRangeKm: pred.dKm,
          calibration: pred.cal
        });
      }

      // Combine and sort targets (time then freq)
      const combined = [...intersectionTargets, ...predictedTargets];

      combined.sort((a, b) => {
        const ta = a.timesSorted?.[0] ?? '';
        const tb = b.timesSorted?.[0] ?? '';
        const da = timeToSortableMinutes(ta);
        const db = timeToSortableMinutes(tb);
        if (da !== db) return da - db;
        return (a.freq ?? 0) - (b.freq ?? 0);
      });

      lastTargets = combined;

      // Render targets table
      targetsTableBody.innerHTML = '';
      combined.forEach((t, idx) => {
        const row = document.createElement('tr');

        const timeCell = (t.timesSorted || []).join(', ');
        const freqCell = Number.isFinite(t.freq) ? t.freq.toFixed(2) : String(t.freq ?? '');
        const lobCountCell = t.lobCount;

        row.innerHTML = `
          <td>${timeCell}</td>
          <td>${t.mgrs}</td>
          <td>${freqCell}</td>
          <td>${lobCountCell}</td>
          <td><button type="button" class="btn-small" data-target-index="${idx}">View</button></td>
        `;
        targetsTableBody.appendChild(row);
      });
    }

    // -----------------------------
    // Target Viewer (Canvas Modal)
    // -----------------------------
    const modalOverlay = document.getElementById('target-modal-overlay');
    const closeModalBtn = document.getElementById('close-target-modal');
    const closeModalBtn2 = document.getElementById('close-target-modal-2');
    const redrawBtn = document.getElementById('redraw-target-modal');
    const modalTitle = document.getElementById('target-modal-title');
    const canvas = document.getElementById('target-canvas');
    const ctx = canvas.getContext('2d');
    const targetDistanceList = document.getElementById('target-distance-list');

    let currentTargetIndex = null;

    function openModal() {
      modalOverlay.classList.add('show');
      modalOverlay.setAttribute('aria-hidden', 'false');
    }

    function closeModal() {
      modalOverlay.classList.remove('show');
      modalOverlay.setAttribute('aria-hidden', 'true');
      currentTargetIndex = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      targetDistanceList.innerHTML = '';
    }

    closeModalBtn.addEventListener('click', closeModal);
    closeModalBtn2.addEventListener('click', closeModal);

    modalOverlay.addEventListener('click', function (e) {
      if (e.target === modalOverlay) closeModal();
    });

    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && modalOverlay.classList.contains('show')) closeModal();
    });

    redrawBtn.addEventListener('click', function () {
      if (currentTargetIndex !== null) drawTargetOverlay(currentTargetIndex);
    });

    targetsTableBody.addEventListener('click', function (e) {
      const btn = e.target.closest('button[data-target-index]');
      if (!btn) return;
      const idx = parseInt(btn.getAttribute('data-target-index'), 10);
      if (!Number.isFinite(idx)) return;
      currentTargetIndex = idx;
      openModal();
      drawTargetOverlay(idx);
    });

    function drawTargetOverlay(targetIndex) {
      const t = lastTargets[targetIndex];
      if (!t) return;

      const kindLabel = (t.type === 'predicted') ? 'Predicted' : 'Intersection';
      modalTitle.textContent = `Target Viewer — ${kindLabel} — ${t.mgrs} — Freq ${Number.isFinite(t.freq) ? t.freq.toFixed(2) : t.freq} — LOBs ${t.lobCount}`;

      const obs = (t.entryIdxs || []).map(i => cachedData[i]).filter(Boolean);
      const intersection = t.point;

      // Ensure ENU frame exists
      if (!enuFrame) ensureEnuFrameFromEntries(obs);

      // Convert intersection ENU -> lon/lat for distance computations
      let intersectionLL = null;
      try {
        intersectionLL = xyToLonLat(intersection.x, intersection.y);
      } catch (err) {
        intersectionLL = null;
      }

      const origins = [];
      const distanceRows = [];

      for (const o of obs) {
        try {
          const ll = window.mgrs.toPoint(String(o.mgrs).trim()); // [lon, lat]
          const km = (intersectionLL)
            ? haversineKm(ll[0], ll[1], intersectionLL.lon, intersectionLL.lat)
            : NaN;

          // Convert source point into ENU meters for drawing
          const p = lonLatToXY(ll[0], ll[1]);

          const freqNum = parseFreq(o.frequency);
          const rssiNum = parseRssi(o.rssi);
          const cal = findCalibrationForFreq(freqNum);
          const rssiRangeKm = cal ? rssiToDistanceKm(rssiNum, cal) : NaN;

          origins.push({ x: p.x, y: p.y, label: `${o.team} ${o.time} — ${Number.isFinite(km) ? km.toFixed(2) : '??'} km` });
          distanceRows.push({
            team: o.team,
            time: o.time,
            mgrs: o.mgrs,
            km,
            rssiRangeKm: Number.isFinite(rssiRangeKm) ? rssiRangeKm : NaN
          });
        } catch (err) {}
      }

      distanceRows.sort((a, b) => (a.km ?? Infinity) - (b.km ?? Infinity));

      if (!distanceRows.length) {
        targetDistanceList.innerHTML = `<div style="font-size:13px;color:rgba(232,238,252,0.7);">No valid source points to calculate distance.</div>`;
      } else {
        targetDistanceList.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th>Time</th>
                <th>Source MGRS</th>
                <th>Distance (km)</th>
                <th>RSSI Range (km)</th>
              </tr>
            </thead>
            <tbody>
              ${distanceRows.map(r => `
                <tr>
                  <td>${r.team}</td>
                  <td>${r.time}</td>
                  <td>${r.mgrs}</td>
                  <td>${Number.isFinite(r.km) ? r.km.toFixed(2) : '??'}</td>
                  <td>${Number.isFinite(r.rssiRangeKm) ? r.rssiRangeKm.toFixed(2) : '—'}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;

        if (t.type === 'predicted' && Number.isFinite(t.predictedRangeKm)) {
          targetDistanceList.innerHTML += `
            <div style="margin-top:8px;font-size:12px;color:rgba(232,238,252,0.75);">
              Predicted range used: <b>${t.predictedRangeKm.toFixed(2)} km</b>
            </div>
          `;
        }
      }

      // Fit canvas bounds around intersection + observer points
      let maxD = 0;
      for (const p of origins) maxD = Math.max(maxD, distMeters(p, intersection));
      const radius = Math.max(500, maxD * 1.25);

      const minX = intersection.x - radius;
      const maxX = intersection.x + radius;
      const minY = intersection.y - radius;
      const maxY = intersection.y + radius;

      const worldW = maxX - minX;
      const worldH = maxY - minY;

      const W = canvas.width;
      const H = canvas.height;
      const scale = Math.min(W / worldW, H / worldH);

      function worldToCanvas(p) {
        const cx = (p.x - minX) * scale;
        const cy = H - (p.y - minY) * scale;
        return { x: cx, y: cy };
      }

      ctx.clearRect(0, 0, W, H);

      const ic = worldToCanvas(intersection);

      // Crosshairs
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.moveTo(ic.x, 0);
      ctx.lineTo(ic.x, H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, ic.y);
      ctx.lineTo(W, ic.y);
      ctx.stroke();
      ctx.restore();

      // Lines from observers to target point
      ctx.save();
      ctx.lineWidth = 2;
      origins.forEach((p) => {
        const a = worldToCanvas(p);
        const b = worldToCanvas(intersection);

        const vx = b.x - a.x;
        const vy = b.y - a.y;
        const len = Math.hypot(vx, vy);
        let bx = b.x, by = b.y;
        if (len > 12) {
          bx = b.x - (vx / len) * 10;
          by = b.y - (vy / len) * 10;
        }

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(bx, by);
        ctx.stroke();
      });
      ctx.restore();

      // Observer points + labels
      ctx.save();
      ctx.font = '12px Arial';
      ctx.textBaseline = 'top';
      origins.forEach((p) => {
        const c = worldToCanvas(p);
        ctx.beginPath();
        ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(p.label, c.x + 8, c.y + 6);
      });
      ctx.restore();

      // Target point
      ctx.save();
      ctx.beginPath();
      ctx.arc(ic.x, ic.y, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = '13px Arial';
      ctx.fillText((t.type === 'predicted') ? 'Predicted' : 'Intersection', ic.x + 12, ic.y + 12);
      ctx.restore();
    }

    // -----------------------------
    // Initial render
    // -----------------------------
    renderTable(cachedData);
    updateTargets();
    renderCalibrationTable();
  </script>
</body>
</html>
