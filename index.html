<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML Interface Project - Teams</title>
  <style>
    /* General Styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
      color: #333;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    h1, h2 {
      color: #333;
      text-align: center;
    }

    .form-wrapper {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin-top: 20px;
    }

    .form-section {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    .form-section h2 {
      text-align: center;
      color: #0056b3;
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 10px;
    }

    input, select {
      padding: 8px;
      margin-top: 5px;
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
      box-sizing: border-box;
    }

    .flex-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: flex-start;
    }

    button {
      padding: 10px 15px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #0056b3;
    }

    .btn-secondary {
      background: #666;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-small {
      padding: 7px 10px;
      font-size: 13px;
    }

    .table-container {
      margin-top: 20px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      border: 1px solid #ddd;
      text-align: left;
      padding: 12px;
      vertical-align: top;
    }

    th {
      background-color: #007bff;
      color: white;
    }

    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    .filters {
      margin-top: 20px;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    /* Hide/show filters */
    .filters-content {
      display: none;
      margin-top: 10px;
    }

    .filters-content.show {
      display: block;
    }

    /* Hide/show settings */
    .settings-content {
      display: none;
      margin-top: 10px;
    }

    .settings-content.show {
      display: block;
    }

    /* Calibration table styling */
    .settings-block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      margin-top: 10px;
      background: #fafafa;
    }

    .settings-block h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: #333;
    }

    .cal-table-wrap {
      overflow-x: auto;
    }

    .cal-table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
    }

    .cal-table th, .cal-table td {
      border: 1px solid #eee;
      padding: 8px;
      vertical-align: middle;
      font-size: 13px;
    }

    .cal-table th {
      background: #f0f0f0;
      color: #333;
      white-space: nowrap;
    }

    .cal-table input {
      margin: 0;
      width: 100%;
      padding: 6px 8px;
      font-size: 13px;
    }

    .cal-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .tiny-note {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
    }

    /* Modal overlay for target viewer */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 9999;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: white;
      width: min(1000px, 100%);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
      overflow: hidden;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      background: #f7f7f7;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 16px;
      color: #333;
    }

    .modal-body {
      padding: 12px;
    }

    .modal-body canvas {
      width: 100%;
      height: 520px;
      border: 1px solid #ddd;
      border-radius: 8px;
      display: block;
      background: #fff;
    }

    .distances-panel {
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      background: #fafafa;
    }

    .distances-panel h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #333;
    }

    .distances-panel table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 6px;
      overflow: hidden;
    }

    .distances-panel th,
    .distances-panel td {
      border: 1px solid #eee;
      padding: 8px 10px;
      font-size: 13px;
    }

    .distances-panel th {
      background: #f0f0f0;
      color: #333;
    }

    .modal-footer {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      padding: 12px 16px;
      border-top: 1px solid #ddd;
      background: #f7f7f7;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Voltage Calculator</h1>

    <!-- Team Sections -->
    <div class="form-wrapper">
      <div class="form-section">
        <h2>Team #1</h2>
        <form id="team1-form">
          <label>
            MGRS Position (Grid Zone XXXX XXXX):
            <input type="text" id="team1-mgrs" placeholder="Enter MGRS Position" required />
          </label>
          <label>
            Line of Bearing (Degrees):
            <input type="number" id="team1-lob" placeholder="Enter LOB" required />
          </label>
          <label>
            Frequency (MHz):
            <input type="text" id="team1-frequency" placeholder="Enter Frequency" required />
          </label>
          <label>
            Received Signal Strength Indicator (RSSI):
            <input type="text" id="team1-rssi" placeholder="Enter RSSI" required />
          </label>
          <button type="submit">Submit</button>
        </form>
      </div>

      <div class="form-section">
        <h2>Team #2</h2>
        <form id="team2-form">
          <label>
            MGRS Position (Grid Zone XXXX XXXX):
            <input type="text" id="team2-mgrs" placeholder="Enter MGRS Position" required />
          </label>
          <label>
            Line of Bearing (Degrees):
            <input type="number" id="team2-lob" placeholder="Enter LOB" required />
          </label>
          <label>
            Frequency (MHz):
            <input type="text" id="team2-frequency" placeholder="Enter Frequency" required />
          </label>
          <label>
            Received Signal Strength Indicator (RSSI):
            <input type="text" id="team2-rssi" placeholder="Enter RSSI" required />
          </label>
          <button type="submit">Submit</button>
        </form>
      </div>
    </div>

    <!-- Targets Feature -->
    <div class="table-container">
      <h2>Targets</h2>
      <table id="targets-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>MGRS</th>
            <th>Frequency</th>
            <th>LOB Count</th>
            <th>View</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Filters + Settings -->
    <div class="filters">
      <div class="controls-row">
        <button type="button" id="toggle-filters-btn">Filter Data</button>
        <button type="button" id="toggle-settings-btn">Settings</button>
      </div>

      <div id="filters-content" class="filters-content">
        <div class="flex-row">
          <label>
            Start Time:
            <input type="time" id="filter-start-time" />
          </label>
          <label>
            End Time:
            <input type="time" id="filter-end-time" />
          </label>
        </div>

        <div class="flex-row">
          <label>
            LOB Start:
            <input type="number" id="filter-lob-start" placeholder="Start" />
          </label>
          <label>
            LOB End:
            <input type="number" id="filter-lob-end" placeholder="End" />
          </label>
          <label>
            MGRS Position:
            <input type="text" id="filter-mgrs" placeholder="Filter MGRS" />
          </label>
        </div>

        <div class="flex-row">
          <label>
            Frequency:
            <input type="text" id="filter-frequency" placeholder="Filter by Frequency" />
          </label>

          <label>
            Team:
            <select id="filter-team">
              <option value="">All Teams</option>
              <option value="Team #1">Team #1</option>
              <option value="Team #2">Team #2</option>
            </select>
          </label>
        </div>

        <div class="button-group">
          <button type="button" id="filter-btn">Apply Filters</button>
          <button type="button" id="reset-filters-btn">Reset Filters</button>
        </div>
      </div>

      <div id="settings-content" class="settings-content">

        <!-- ROT -->
        <div class="settings-block">
          <h3>ROT</h3>
          <div class="flex-row">
            <label style="flex:1;">
              ROT (0-9):
              <input type="number" id="settings-rot" placeholder="0" min="0" max="9" inputmode="numeric" />
            </label>
          </div>
          <div class="tiny-note">ROT adjusts only the numeric part of MGRS after the grid zone (e.g., 18SUJ stays unchanged).</div>
        </div>

        <!-- Calibration -->
        <div class="settings-block">
          <h3>Calibration</h3>

          <div class="cal-table-wrap">
            <table class="cal-table">
              <thead>
                <tr>
                  <th>Frequency Start</th>
                  <th>Frequency End</th>
                  <th>System</th>
                  <th>5km</th>
                  <th>10km</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="calibration-tbody"></tbody>
            </table>
          </div>

          <div class="cal-actions">
            <button type="button" id="calibration-add-btn" class="btn-secondary btn-small">Add</button>
            <button type="button" id="calibration-clear-btn" class="btn-secondary btn-small">Clear Calibration</button>
          </div>

          <div class="tiny-note">Add creates a new row. Update saves that row into localStorage.</div>
        </div>

      </div>
    </div>

    <!-- Data Table -->
    <div class="table-container">
      <h2>Signal Database</h2>
      <table id="data-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Team</th>
            <th>MGRS Position</th>
            <th>Line of Bearing (LOB)</th>
            <th>Frequency</th>
            <th>RSSI</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Download and Clear Cache Buttons -->
    <div class="button-group">
      <button id="download-btn">Download as CSV</button>
      <button id="clear-cache-btn">Clear Cache</button>
    </div>
  </div>

  <!-- Modal for Target Viewer -->
  <div id="target-modal-overlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Target Viewer">
      <div class="modal-header">
        <h3 id="target-modal-title">Target Viewer</h3>
        <button type="button" id="close-target-modal" class="btn-secondary btn-small">Close</button>
      </div>
      <div class="modal-body">
        <canvas id="target-canvas" width="1000" height="520"></canvas>

        <div class="distances-panel" id="target-distance-panel">
          <h4>Distances to Intersection</h4>
          <div id="target-distance-list"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" id="redraw-target-modal" class="btn-secondary btn-small">Redraw</button>
        <button type="button" id="close-target-modal-2" class="btn-secondary btn-small">Close</button>
      </div>
    </div>
  </div>

  <!-- MGRS conversion library -->
  <script src="https://unpkg.com/mgrs/dist/mgrs.min.js"></script>

  <script>
    // -----------------------------
    // Storage Keys
    // -----------------------------
    const LOCAL_STORAGE_KEY = 'cachedData';
    const ROT_STORAGE_KEY = 'settingsROT';
    const CAL_STORAGE_KEY = 'calibrationRows';

    // -----------------------------
    // App Data
    // -----------------------------
    let cachedData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || [];
    let calibrationRows = JSON.parse(localStorage.getItem(CAL_STORAGE_KEY)) || [];

    // -----------------------------
    // ROT helpers
    // -----------------------------
    function getRot() {
      const raw = localStorage.getItem(ROT_STORAGE_KEY);
      const n = raw === null ? 0 : parseInt(raw, 10);
      if (!Number.isFinite(n)) return 0;
      return Math.min(9, Math.max(0, n));
    }

    function setRot(val) {
      const n = parseInt(val, 10);
      const safe = Number.isFinite(n) ? Math.min(9, Math.max(0, n)) : 0;
      localStorage.setItem(ROT_STORAGE_KEY, String(safe));
      return safe;
    }

    // ROT applies only after the MGRS prefix (e.g., 18SUJ)
    function applyRotToMgrs(mgrsStr, rot) {
      const r = Number(rot);
      const shift = Number.isFinite(r) ? ((Math.trunc(r) % 10) + 10) % 10 : 0;
      const s = String(mgrsStr).trim();
      if (shift === 0) return s;

      const m = s.match(/^(\d{1,2}[C-HJ-NP-X][A-HJ-NP-Z]{2})(.*)$/i);
      if (m) {
        const prefix = m[1];
        const rest = m[2];
        const rotatedRest = rest.replace(/\d/g, d => String((Number(d) + shift) % 10));
        return prefix + rotatedRest;
      }

      const parts = s.split(/\s+/);
      if (parts.length <= 1) return s;
      const prefixToken = parts.shift();
      const restJoined = parts.join(' ');
      const rotatedRest = restJoined.replace(/\d/g, d => String((Number(d) + shift) % 10));
      return prefixToken + ' ' + rotatedRest;
    }

    // -----------------------------
    // DOM refs
    // -----------------------------
    const team1Form = document.getElementById('team1-form');
    const team2Form = document.getElementById('team2-form');

    const filterBtn = document.getElementById('filter-btn');
    const resetFiltersBtn = document.getElementById('reset-filters-btn');
    const downloadBtn = document.getElementById('download-btn');
    const clearCacheBtn = document.getElementById('clear-cache-btn');

    const dataTable = document.getElementById('data-table').querySelector('tbody');
    const targetsTableBody = document.getElementById('targets-table').querySelector('tbody');

    const toggleFiltersBtn = document.getElementById('toggle-filters-btn');
    const filtersContent = document.getElementById('filters-content');

    const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
    const settingsContent = document.getElementById('settings-content');

    const rotInput = document.getElementById('settings-rot');

    // Calibration DOM
    const calTbody = document.getElementById('calibration-tbody');
    const calAddBtn = document.getElementById('calibration-add-btn');
    const calClearBtn = document.getElementById('calibration-clear-btn');

    // -----------------------------
    // Toggle UI
    // -----------------------------
    toggleFiltersBtn.addEventListener('click', function () {
      filtersContent.classList.toggle('show');
    });

    toggleSettingsBtn.addEventListener('click', function () {
      settingsContent.classList.toggle('show');
    });

    // -----------------------------
    // ROT input behavior
    // -----------------------------
    rotInput.value = String(getRot());
    rotInput.addEventListener('input', function () {
      let v = rotInput.value.replace(/[^\d]/g, '');
      if (v === '') v = '0';
      v = String(Math.min(9, Math.max(0, parseInt(v, 10) || 0)));
      rotInput.value = v;
      setRot(v);
    });

    // -----------------------------
    // Calibration
    // -----------------------------
    function saveCalibration() {
      localStorage.setItem(CAL_STORAGE_KEY, JSON.stringify(calibrationRows));
    }

    function makeRowId() {
      return 'cal_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function renderCalibrationTable() {
      calTbody.innerHTML = '';
      if (!Array.isArray(calibrationRows)) calibrationRows = [];

      calibrationRows.forEach((row) => {
        const tr = document.createElement('tr');
        tr.dataset.rowId = row.id;

        tr.innerHTML = `
          <td><input type="text" value="${escapeHtml(row.freqStart ?? '')}" placeholder="e.g., 30.00" /></td>
          <td><input type="text" value="${escapeHtml(row.freqEnd ?? '')}" placeholder="e.g., 30.50" /></td>
          <td><input type="text" value="${escapeHtml(row.system ?? '')}" placeholder="e.g., System A" /></td>
          <td><input type="text" value="${escapeHtml(row.km5 ?? '')}" placeholder="" /></td>
          <td><input type="text" value="${escapeHtml(row.km10 ?? '')}" placeholder="" /></td>
          <td style="white-space:nowrap;">
            <button type="button" class="btn-secondary btn-small cal-update-btn">Update</button>
          </td>
        `;
        calTbody.appendChild(tr);
      });
    }

    calAddBtn.addEventListener('click', function () {
      calibrationRows.push({
        id: makeRowId(),
        freqStart: '',
        freqEnd: '',
        system: '',
        km5: '',
        km10: ''
      });
      saveCalibration();
      renderCalibrationTable();
    });

    calClearBtn.addEventListener('click', function () {
      if (confirm('Clear all calibration rows?')) {
        calibrationRows = [];
        saveCalibration();
        renderCalibrationTable();
      }
    });

    calTbody.addEventListener('click', function (e) {
      const btn = e.target.closest('.cal-update-btn');
      if (!btn) return;

      const tr = btn.closest('tr');
      if (!tr) return;

      const rowId = tr.dataset.rowId;
      const inputs = tr.querySelectorAll('input');
      if (inputs.length < 5) return;

      const updated = {
        id: rowId,
        freqStart: inputs[0].value.trim(),
        freqEnd: inputs[1].value.trim(),
        system: inputs[2].value.trim(),
        km5: inputs[3].value.trim(),
        km10: inputs[4].value.trim()
      };

      const idx = calibrationRows.findIndex(r => r.id === rowId);
      if (idx === -1) return;

      calibrationRows[idx] = updated;
      saveCalibration();

      btn.textContent = 'Saved';
      setTimeout(() => { btn.textContent = 'Update'; }, 650);
    });

    // -----------------------------
    // Data Table Rendering
    // -----------------------------
    function renderTable(data) {
      dataTable.innerHTML = '';
      data.forEach(({ time, team, mgrs, lob, frequency, rssi }) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${time}</td>
          <td>${team}</td>
          <td>${mgrs}</td>
          <td>${lob}</td>
          <td>${frequency}</td>
          <td>${rssi ?? ''}</td>
        `;
        dataTable.appendChild(row);
      });
    }

    function submitData(team, mgrsId, lobId, frequencyId, rssiId) {
      const mgrsRaw = document.getElementById(mgrsId).value.trim();
      const lob = parseFloat(document.getElementById(lobId).value);
      const frequency = document.getElementById(frequencyId).value.trim();
      const rssi = document.getElementById(rssiId).value.trim();
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

      if (!mgrsRaw || isNaN(lob) || !frequency || !rssi) {
        alert('Please fill all fields.');
        return;
      }

      const rot = getRot();
      const mgrs = applyRotToMgrs(mgrsRaw, rot);

      const newEntry = { time, team, mgrs, lob, frequency, rssi };
      cachedData.push(newEntry);
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(cachedData));

      document.getElementById(mgrsId).value = mgrsRaw; // keep unrotated visible
      document.getElementById(lobId).value = '';
      document.getElementById(frequencyId).value = '';
      document.getElementById(rssiId).value = '';

      renderTable(cachedData);
      updateTargets();
    }

    team1Form.addEventListener('submit', function (e) {
      e.preventDefault();
      submitData('Team #1', 'team1-mgrs', 'team1-lob', 'team1-frequency', 'team1-rssi');
    });

    team2Form.addEventListener('submit', function (e) {
      e.preventDefault();
      submitData('Team #2', 'team2-mgrs', 'team2-lob', 'team2-frequency', 'team2-rssi');
    });

    // -----------------------------
    // Filters
    // -----------------------------
    function applyFilters() {
      const startTime = document.getElementById('filter-start-time').value;
      const endTime = document.getElementById('filter-end-time').value;
      const lobStart = parseFloat(document.getElementById('filter-lob-start').value);
      const lobEnd = parseFloat(document.getElementById('filter-lob-end').value);
      const mgrsFilter = document.getElementById('filter-mgrs').value.trim();
      const freqFilter = document.getElementById('filter-frequency').value.trim();
      const teamFilter = document.getElementById('filter-team').value;

      const startMinutes = startTime ? parseInt(startTime.split(':')[0]) * 60 + parseInt(startTime.split(':')[1]) : null;
      const endMinutes = endTime ? parseInt(endTime.split(':')[0]) * 60 + parseInt(endTime.split(':')[1]) : null;

      const filtered = cachedData.filter(({ time, lob, frequency, mgrs, team }) => {
        const [hours, minutes] = time.split(':').map(Number);
        const entryMinutes = hours * 60 + minutes;

        return (!startMinutes || entryMinutes >= startMinutes) &&
               (!endMinutes || entryMinutes <= endMinutes) &&
               (isNaN(lobStart) || lob >= lobStart) &&
               (isNaN(lobEnd) || lob <= lobEnd) &&
               (freqFilter ? String(frequency).includes(freqFilter) : true) &&
               (mgrsFilter ? String(mgrs).includes(mgrsFilter) : true) &&
               (teamFilter ? team === teamFilter : true);
      });

      renderTable(filtered);
    }

    filterBtn.addEventListener('click', applyFilters);

    resetFiltersBtn.addEventListener('click', function () {
      document.getElementById('filter-start-time').value = '';
      document.getElementById('filter-end-time').value = '';
      document.getElementById('filter-lob-start').value = '';
      document.getElementById('filter-lob-end').value = '';
      document.getElementById('filter-mgrs').value = '';
      document.getElementById('filter-frequency').value = '';
      document.getElementById('filter-team').value = '';
      renderTable(cachedData);
    });

    // -----------------------------
    // Cache controls
    // -----------------------------
    clearCacheBtn.addEventListener('click', function () {
      if (confirm('Are you sure you want to clear all cached data?')) {
        cachedData = [];
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        renderTable(cachedData);
        updateTargets();
      }
    });

    downloadBtn.addEventListener('click', function () {
      if (!cachedData.length) {
        alert('No data to download.');
        return;
      }

      const headers = ['Time', 'Team', 'MGRS Position', 'Line of Bearing (LOB)', 'Frequency', 'RSSI'];
      const csvContent = [headers.join(','), ...cachedData.map(entry =>
        `${entry.time},${entry.team},${entry.mgrs},${entry.lob},${entry.frequency},${entry.rssi}`
      )].join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `cached_data.csv`;
      a.click();

      URL.revokeObjectURL(url);
    });

    // -----------------------------
    // Targets Logic (unchanged)
    // -----------------------------
    const LOB_LENGTH_METERS = 50 * 1609.344; // 50 miles
    const FREQ_TOL = 0.25;
    const MIN_ANGLE_DEG = 5;
    const MERGE_INTERSECTION_METERS = 100;

    function normalizeAngle(deg) {
      let a = deg % 360;
      if (a < 0) a += 360;
      return a;
    }

    function angleDiffDeg(a, b) {
      const d = Math.abs(normalizeAngle(a) - normalizeAngle(b)) % 360;
      return d > 180 ? 360 - d : d;
    }

    function parseFreq(val) {
      const m = String(val).match(/-?\d+(\.\d+)?/);
      return m ? parseFloat(m[0]) : NaN;
    }

    const R = 6378137;

    function lonLatToMercatorMeters(lon, lat) {
      const x = R * (lon * Math.PI / 180);
      const y = R * Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 180) / 2));
      return { x, y };
    }

    function mercatorMetersToLonLat(x, y) {
      const lon = (x / R) * 180 / Math.PI;
      const lat = (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * 180 / Math.PI;
      return { lon, lat };
    }

    function mgrsToXY(mgrsStr) {
      const ll = window.mgrs.toPoint(String(mgrsStr).trim()); // [lon, lat]
      return lonLatToMercatorMeters(ll[0], ll[1]);
    }

    function xyToMgrs(x, y) {
      const { lon, lat } = mercatorMetersToLonLat(x, y);
      return window.mgrs.forward([lon, lat], 5);
    }

    function segmentFromEntry(entry) {
      const p = mgrsToXY(entry.mgrs);
      const az = normalizeAngle(parseFloat(entry.lob));
      const rad = az * Math.PI / 180;

      const dx = Math.sin(rad);
      const dy = Math.cos(rad);

      const x2 = p.x + dx * LOB_LENGTH_METERS;
      const y2 = p.y + dy * LOB_LENGTH_METERS;

      return { x1: p.x, y1: p.y, x2, y2 };
    }

    function segmentIntersection(segA, segB) {
      const x1 = segA.x1, y1 = segA.y1, x2 = segA.x2, y2 = segA.y2;
      const x3 = segB.x1, y3 = segB.y1, x4 = segB.x2, y4 = segB.y2;

      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 1e-9) return null;

      const px = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / denom;
      const py = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / denom;

      function within(a, b, p) {
        return p >= Math.min(a, b) - 1e-6 && p <= Math.max(a, b) + 1e-6;
      }

      if (!within(x1, x2, px) || !within(y1, y2, py) || !within(x3, x4, px) || !within(y3, y4, py)) {
        return null;
      }

      return { x: px, y: py };
    }

    function distMeters(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function timeToSortableMinutes(t) {
      const parts = String(t).split(':');
      const h = parseInt(parts[0], 10);
      const m = parseInt(parts[1], 10);
      if (isNaN(h) || isNaN(m)) return Number.MAX_SAFE_INTEGER;
      return h * 60 + m;
    }

    function haversineKm(lon1, lat1, lon2, lat2) {
      const toRad = d => d * Math.PI / 180;
      const Rm = 6371008.8;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return (Rm * c) / 1000;
    }

    let lastTargets = [];

    function updateTargets() {
      if (!window.mgrs || typeof window.mgrs.toPoint !== 'function') {
        targetsTableBody.innerHTML = '';
        lastTargets = [];
        return;
      }

      const entries = [];
      for (let i = 0; i < cachedData.length; i++) {
        const e = cachedData[i];
        const f = parseFreq(e.frequency);
        const lob = parseFloat(e.lob);

        if (!Number.isFinite(f) || !Number.isFinite(lob)) continue;

        try { mgrsToXY(e.mgrs); } catch (err) { continue; }

        entries.push({ ...e, _idx: i, _freqNum: f, _lobNum: lob });
      }

      const targets = [];
      for (let i = 0; i < entries.length; i++) {
        for (let j = i + 1; j < entries.length; j++) {
          const a = entries[i];
          const b = entries[j];

          if (Math.abs(a._freqNum - b._freqNum) > FREQ_TOL) continue;
          if (angleDiffDeg(a._lobNum, b._lobNum) <= MIN_ANGLE_DEG) continue;

          let inter = null;
          try {
            const segA = segmentFromEntry(a);
            const segB = segmentFromEntry(b);
            inter = segmentIntersection(segA, segB);
          } catch (err) {
            inter = null;
          }
          if (!inter) continue;

          const freqMid = (a._freqNum + b._freqNum) / 2;

          let merged = null;
          for (const t of targets) {
            if (Math.abs(t.freq - freqMid) <= FREQ_TOL && distMeters(t.point, inter) <= MERGE_INTERSECTION_METERS) {
              merged = t;
              break;
            }
          }

          if (!merged) {
            merged = { point: inter, freq: freqMid, entryIdxSet: new Set(), times: new Set() };
            targets.push(merged);
          }

          merged.entryIdxSet.add(a._idx);
          merged.entryIdxSet.add(b._idx);
          merged.times.add(a.time);
          merged.times.add(b.time);
        }
      }

      const filteredTargets = targets
        .filter(t => t.entryIdxSet.size >= 2)
        .map(t => {
          let mgrsOut = '';
          try { mgrsOut = xyToMgrs(t.point.x, t.point.y); } catch (err) { mgrsOut = 'MGRS ERROR'; }
          const timesSorted = Array.from(t.times).sort((a, b) => timeToSortableMinutes(a) - timeToSortableMinutes(b));
          return {
            point: t.point,
            freq: t.freq,
            mgrs: mgrsOut,
            lobCount: t.entryIdxSet.size,
            entryIdxs: Array.from(t.entryIdxSet),
            timesSorted
          };
        });

      lastTargets = filteredTargets;

      targetsTableBody.innerHTML = '';
      filteredTargets.forEach((t, idx) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${t.timesSorted.join(', ')}</td>
          <td>${t.mgrs}</td>
          <td>${t.freq.toFixed(2)}</td>
          <td>${t.lobCount}</td>
          <td><button type="button" class="btn-small" data-target-index="${idx}">View</button></td>
        `;
        targetsTableBody.appendChild(row);
      });
    }

    // -----------------------------
    // Target Viewer (Canvas Modal)
    // -----------------------------
    const modalOverlay = document.getElementById('target-modal-overlay');
    const closeModalBtn = document.getElementById('close-target-modal');
    const closeModalBtn2 = document.getElementById('close-target-modal-2');
    const redrawBtn = document.getElementById('redraw-target-modal');
    const modalTitle = document.getElementById('target-modal-title');
    const canvas = document.getElementById('target-canvas');
    const ctx = canvas.getContext('2d');
    const targetDistanceList = document.getElementById('target-distance-list');

    let currentTargetIndex = null;

    function openModal() {
      modalOverlay.classList.add('show');
      modalOverlay.setAttribute('aria-hidden', 'false');
    }

    function closeModal() {
      modalOverlay.classList.remove('show');
      modalOverlay.setAttribute('aria-hidden', 'true');
      currentTargetIndex = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      targetDistanceList.innerHTML = '';
    }

    closeModalBtn.addEventListener('click', closeModal);
    closeModalBtn2.addEventListener('click', closeModal);

    modalOverlay.addEventListener('click', function (e) {
      if (e.target === modalOverlay) closeModal();
    });

    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && modalOverlay.classList.contains('show')) closeModal();
    });

    redrawBtn.addEventListener('click', function () {
      if (currentTargetIndex !== null) drawTargetOverlay(currentTargetIndex);
    });

    targetsTableBody.addEventListener('click', function (e) {
      const btn = e.target.closest('button[data-target-index]');
      if (!btn) return;
      const idx = parseInt(btn.getAttribute('data-target-index'), 10);
      if (!Number.isFinite(idx)) return;
      currentTargetIndex = idx;
      openModal();
      drawTargetOverlay(idx);
    });

    function drawTargetOverlay(targetIndex) {
      const t = lastTargets[targetIndex];
      if (!t) return;

      modalTitle.textContent = `Target Viewer — ${t.mgrs} — Freq ${t.freq.toFixed(2)} — LOBs ${t.lobCount}`;

      const obs = t.entryIdxs.map(i => cachedData[i]).filter(Boolean);
      const intersection = t.point;
      const intersectionLL = mercatorMetersToLonLat(intersection.x, intersection.y);

      const origins = [];
      const distanceRows = [];

      for (const o of obs) {
        try {
          const ll = window.mgrs.toPoint(String(o.mgrs).trim());
          const km = haversineKm(ll[0], ll[1], intersectionLL.lon, intersectionLL.lat);
          const p = lonLatToMercatorMeters(ll[0], ll[1]);

          origins.push({ x: p.x, y: p.y, label: `${o.team} ${o.time} — ${km.toFixed(2)} km` });
          distanceRows.push({ team: o.team, time: o.time, mgrs: o.mgrs, km });
        } catch (err) {}
      }

      distanceRows.sort((a, b) => a.km - b.km);
      if (!distanceRows.length) {
        targetDistanceList.innerHTML = `<div style="font-size:13px;color:#555;">No valid source points to calculate distance.</div>`;
      } else {
        targetDistanceList.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th>Time</th>
                <th>Source MGRS</th>
                <th>Distance (km)</th>
              </tr>
            </thead>
            <tbody>
              ${distanceRows.map(r => `
                <tr>
                  <td>${r.team}</td>
                  <td>${r.time}</td>
                  <td>${r.mgrs}</td>
                  <td>${r.km.toFixed(2)}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;
      }

      let maxD = 0;
      for (const p of origins) maxD = Math.max(maxD, distMeters(p, intersection));
      const radius = Math.max(500, maxD * 1.25);

      const minX = intersection.x - radius;
      const maxX = intersection.x + radius;
      const minY = intersection.y - radius;
      const maxY = intersection.y + radius;

      const worldW = maxX - minX;
      const worldH = maxY - minY;

      const W = canvas.width;
      const H = canvas.height;
      const scale = Math.min(W / worldW, H / worldH);

      function worldToCanvas(p) {
        const cx = (p.x - minX) * scale;
        const cy = H - (p.y - minY) * scale;
        return { x: cx, y: cy };
      }

      ctx.clearRect(0, 0, W, H);

      const ic = worldToCanvas(intersection);
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      ctx.moveTo(ic.x, 0);
      ctx.lineTo(ic.x, H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, ic.y);
      ctx.lineTo(W, ic.y);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.lineWidth = 2;
      origins.forEach((p) => {
        const a = worldToCanvas(p);
        const b = worldToCanvas(intersection);

        const vx = b.x - a.x;
        const vy = b.y - a.y;
        const len = Math.hypot(vx, vy);
        let bx = b.x, by = b.y;
        if (len > 12) {
          bx = b.x - (vx / len) * 10;
          by = b.y - (vy / len) * 10;
        }

        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(bx, by);
        ctx.stroke();
      });
      ctx.restore();

      ctx.save();
      ctx.font = '12px Arial';
      ctx.textBaseline = 'top';
      origins.forEach((p) => {
        const c = worldToCanvas(p);
        ctx.beginPath();
        ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(p.label, c.x + 8, c.y + 6);
      });
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.arc(ic.x, ic.y, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = '13px Arial';
      ctx.fillText('Intersection', ic.x + 12, ic.y + 12);
      ctx.restore();
    }

    // -----------------------------
    // Initial render
    // -----------------------------
    renderTable(cachedData);
    updateTargets();
    renderCalibrationTable();
  </script>
</body>
</html>
